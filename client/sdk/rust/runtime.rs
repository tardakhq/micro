// This file is generated by rust-protobuf 2.18.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `runtime/runtime.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_0;

#[derive(PartialEq,Clone,Default)]
pub struct Resource {
    // message fields
    pub namespace: ::protobuf::SingularPtrField<Namespace>,
    pub networkpolicy: ::protobuf::SingularPtrField<NetworkPolicy>,
    pub service: ::protobuf::SingularPtrField<Service>,
    pub resourcequota: ::protobuf::SingularPtrField<ResourceQuota>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Resource {
    fn default() -> &'a Resource {
        <Resource as ::protobuf::Message>::default_instance()
    }
}

impl Resource {
    pub fn new() -> Resource {
        ::std::default::Default::default()
    }

    // .runtime.Namespace namespace = 1;


    pub fn get_namespace(&self) -> &Namespace {
        self.namespace.as_ref().unwrap_or_else(|| <Namespace as ::protobuf::Message>::default_instance())
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: Namespace) {
        self.namespace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut Namespace {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> Namespace {
        self.namespace.take().unwrap_or_else(|| Namespace::new())
    }

    // .runtime.NetworkPolicy networkpolicy = 2;


    pub fn get_networkpolicy(&self) -> &NetworkPolicy {
        self.networkpolicy.as_ref().unwrap_or_else(|| <NetworkPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_networkpolicy(&mut self) {
        self.networkpolicy.clear();
    }

    pub fn has_networkpolicy(&self) -> bool {
        self.networkpolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_networkpolicy(&mut self, v: NetworkPolicy) {
        self.networkpolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_networkpolicy(&mut self) -> &mut NetworkPolicy {
        if self.networkpolicy.is_none() {
            self.networkpolicy.set_default();
        }
        self.networkpolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_networkpolicy(&mut self) -> NetworkPolicy {
        self.networkpolicy.take().unwrap_or_else(|| NetworkPolicy::new())
    }

    // .runtime.Service service = 3;


    pub fn get_service(&self) -> &Service {
        self.service.as_ref().unwrap_or_else(|| <Service as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: Service) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut Service {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> Service {
        self.service.take().unwrap_or_else(|| Service::new())
    }

    // .runtime.ResourceQuota resourcequota = 4;


    pub fn get_resourcequota(&self) -> &ResourceQuota {
        self.resourcequota.as_ref().unwrap_or_else(|| <ResourceQuota as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resourcequota(&mut self) {
        self.resourcequota.clear();
    }

    pub fn has_resourcequota(&self) -> bool {
        self.resourcequota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourcequota(&mut self, v: ResourceQuota) {
        self.resourcequota = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourcequota(&mut self) -> &mut ResourceQuota {
        if self.resourcequota.is_none() {
            self.resourcequota.set_default();
        }
        self.resourcequota.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourcequota(&mut self) -> ResourceQuota {
        self.resourcequota.take().unwrap_or_else(|| ResourceQuota::new())
    }
}

impl ::protobuf::Message for Resource {
    fn is_initialized(&self) -> bool {
        for v in &self.namespace {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.networkpolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resourcequota {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.namespace)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.networkpolicy)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourcequota)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.namespace.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.networkpolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resourcequota.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.networkpolicy.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resourcequota.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Resource {
        Resource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Namespace>>(
                "namespace",
                |m: &Resource| { &m.namespace },
                |m: &mut Resource| { &mut m.namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkPolicy>>(
                "networkpolicy",
                |m: &Resource| { &m.networkpolicy },
                |m: &mut Resource| { &mut m.networkpolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "service",
                |m: &Resource| { &m.service },
                |m: &mut Resource| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceQuota>>(
                "resourcequota",
                |m: &Resource| { &m.resourcequota },
                |m: &mut Resource| { &mut m.resourcequota },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Resource>(
                "Resource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Resource {
        static instance: ::protobuf::rt::LazyV2<Resource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Resource::new)
    }
}

impl ::protobuf::Clear for Resource {
    fn clear(&mut self) {
        self.namespace.clear();
        self.networkpolicy.clear();
        self.service.clear();
        self.resourcequota.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Namespace {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Namespace {
    fn default() -> &'a Namespace {
        <Namespace as ::protobuf::Message>::default_instance()
    }
}

impl Namespace {
    pub fn new() -> Namespace {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Namespace {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Namespace {
        Namespace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Namespace| { &m.name },
                |m: &mut Namespace| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Namespace>(
                "Namespace",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Namespace {
        static instance: ::protobuf::rt::LazyV2<Namespace> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Namespace::new)
    }
}

impl ::protobuf::Clear for Namespace {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Namespace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Namespace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkPolicy {
    // message fields
    pub allowedlabels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub name: ::std::string::String,
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkPolicy {
    fn default() -> &'a NetworkPolicy {
        <NetworkPolicy as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicy {
    pub fn new() -> NetworkPolicy {
        ::std::default::Default::default()
    }

    // repeated .runtime.NetworkPolicy.AllowedlabelsEntry allowedlabels = 1;


    pub fn get_allowedlabels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.allowedlabels
    }
    pub fn clear_allowedlabels(&mut self) {
        self.allowedlabels.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowedlabels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.allowedlabels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowedlabels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.allowedlabels
    }

    // Take field
    pub fn take_allowedlabels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.allowedlabels, ::std::collections::HashMap::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string namespace = 3;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NetworkPolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.allowedlabels)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.allowedlabels);
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.allowedlabels, os)?;
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(3, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkPolicy {
        NetworkPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "allowedlabels",
                |m: &NetworkPolicy| { &m.allowedlabels },
                |m: &mut NetworkPolicy| { &mut m.allowedlabels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &NetworkPolicy| { &m.name },
                |m: &mut NetworkPolicy| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &NetworkPolicy| { &m.namespace },
                |m: &mut NetworkPolicy| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkPolicy>(
                "NetworkPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkPolicy {
        static instance: ::protobuf::rt::LazyV2<NetworkPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkPolicy::new)
    }
}

impl ::protobuf::Clear for NetworkPolicy {
    fn clear(&mut self) {
        self.allowedlabels.clear();
        self.name.clear();
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceQuota {
    // message fields
    pub name: ::std::string::String,
    pub namespace: ::std::string::String,
    pub requests: ::protobuf::SingularPtrField<Resources>,
    pub limits: ::protobuf::SingularPtrField<Resources>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceQuota {
    fn default() -> &'a ResourceQuota {
        <ResourceQuota as ::protobuf::Message>::default_instance()
    }
}

impl ResourceQuota {
    pub fn new() -> ResourceQuota {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string namespace = 2;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }

    // .runtime.Resources requests = 3;


    pub fn get_requests(&self) -> &Resources {
        self.requests.as_ref().unwrap_or_else(|| <Resources as ::protobuf::Message>::default_instance())
    }
    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    pub fn has_requests(&self) -> bool {
        self.requests.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: Resources) {
        self.requests = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requests(&mut self) -> &mut Resources {
        if self.requests.is_none() {
            self.requests.set_default();
        }
        self.requests.as_mut().unwrap()
    }

    // Take field
    pub fn take_requests(&mut self) -> Resources {
        self.requests.take().unwrap_or_else(|| Resources::new())
    }

    // .runtime.Resources limits = 4;


    pub fn get_limits(&self) -> &Resources {
        self.limits.as_ref().unwrap_or_else(|| <Resources as ::protobuf::Message>::default_instance())
    }
    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    pub fn has_limits(&self) -> bool {
        self.limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: Resources) {
        self.limits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limits(&mut self) -> &mut Resources {
        if self.limits.is_none() {
            self.limits.set_default();
        }
        self.limits.as_mut().unwrap()
    }

    // Take field
    pub fn take_limits(&mut self) -> Resources {
        self.limits.take().unwrap_or_else(|| Resources::new())
    }
}

impl ::protobuf::Message for ResourceQuota {
    fn is_initialized(&self) -> bool {
        for v in &self.requests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.limits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.requests)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.namespace);
        }
        if let Some(ref v) = self.requests.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.limits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(2, &self.namespace)?;
        }
        if let Some(ref v) = self.requests.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.limits.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceQuota {
        ResourceQuota::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ResourceQuota| { &m.name },
                |m: &mut ResourceQuota| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &ResourceQuota| { &m.namespace },
                |m: &mut ResourceQuota| { &mut m.namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resources>>(
                "requests",
                |m: &ResourceQuota| { &m.requests },
                |m: &mut ResourceQuota| { &mut m.requests },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resources>>(
                "limits",
                |m: &ResourceQuota| { &m.limits },
                |m: &mut ResourceQuota| { &mut m.limits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceQuota>(
                "ResourceQuota",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceQuota {
        static instance: ::protobuf::rt::LazyV2<ResourceQuota> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceQuota::new)
    }
}

impl ::protobuf::Clear for ResourceQuota {
    fn clear(&mut self) {
        self.name.clear();
        self.namespace.clear();
        self.requests.clear();
        self.limits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceQuota {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuota {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Resources {
    // message fields
    pub Memory: i32,
    pub CPU: i32,
    pub EphemeralStorage: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Resources {
    fn default() -> &'a Resources {
        <Resources as ::protobuf::Message>::default_instance()
    }
}

impl Resources {
    pub fn new() -> Resources {
        ::std::default::Default::default()
    }

    // int32 Memory = 1;


    pub fn get_Memory(&self) -> i32 {
        self.Memory
    }
    pub fn clear_Memory(&mut self) {
        self.Memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_Memory(&mut self, v: i32) {
        self.Memory = v;
    }

    // int32 CPU = 2;


    pub fn get_CPU(&self) -> i32 {
        self.CPU
    }
    pub fn clear_CPU(&mut self) {
        self.CPU = 0;
    }

    // Param is passed by value, moved
    pub fn set_CPU(&mut self, v: i32) {
        self.CPU = v;
    }

    // int32 EphemeralStorage = 3;


    pub fn get_EphemeralStorage(&self) -> i32 {
        self.EphemeralStorage
    }
    pub fn clear_EphemeralStorage(&mut self) {
        self.EphemeralStorage = 0;
    }

    // Param is passed by value, moved
    pub fn set_EphemeralStorage(&mut self, v: i32) {
        self.EphemeralStorage = v;
    }
}

impl ::protobuf::Message for Resources {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Memory = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.CPU = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.EphemeralStorage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Memory != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Memory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.CPU != 0 {
            my_size += ::protobuf::rt::value_size(2, self.CPU, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EphemeralStorage != 0 {
            my_size += ::protobuf::rt::value_size(3, self.EphemeralStorage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Memory != 0 {
            os.write_int32(1, self.Memory)?;
        }
        if self.CPU != 0 {
            os.write_int32(2, self.CPU)?;
        }
        if self.EphemeralStorage != 0 {
            os.write_int32(3, self.EphemeralStorage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Resources {
        Resources::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "Memory",
                |m: &Resources| { &m.Memory },
                |m: &mut Resources| { &mut m.Memory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "CPU",
                |m: &Resources| { &m.CPU },
                |m: &mut Resources| { &mut m.CPU },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "EphemeralStorage",
                |m: &Resources| { &m.EphemeralStorage },
                |m: &mut Resources| { &mut m.EphemeralStorage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Resources>(
                "Resources",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Resources {
        static instance: ::protobuf::rt::LazyV2<Resources> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Resources::new)
    }
}

impl ::protobuf::Clear for Resources {
    fn clear(&mut self) {
        self.Memory = 0;
        self.CPU = 0;
        self.EphemeralStorage = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Resources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resources {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Service {
    // message fields
    pub name: ::std::string::String,
    pub version: ::std::string::String,
    pub source: ::std::string::String,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub status: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service {
    fn default() -> &'a Service {
        <Service as ::protobuf::Message>::default_instance()
    }
}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string source = 3;


    pub fn get_source(&self) -> &str {
        &self.source
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    // repeated .runtime.Service.MetadataEntry metadata = 4;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    // int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }
}

impl ::protobuf::Message for Service {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.metadata);
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(5, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if !self.source.is_empty() {
            os.write_string(3, &self.source)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.metadata, os)?;
        if self.status != 0 {
            os.write_int32(5, self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service {
        Service::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Service| { &m.name },
                |m: &mut Service| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &Service| { &m.version },
                |m: &mut Service| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source",
                |m: &Service| { &m.source },
                |m: &mut Service| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &Service| { &m.metadata },
                |m: &mut Service| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &Service| { &m.status },
                |m: &mut Service| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service>(
                "Service",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Service {
        static instance: ::protobuf::rt::LazyV2<Service> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Service::new)
    }
}

impl ::protobuf::Clear for Service {
    fn clear(&mut self) {
        self.name.clear();
        self.version.clear();
        self.source.clear();
        self.metadata.clear();
        self.status = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateOptions {
    // message fields
    pub command: ::protobuf::RepeatedField<::std::string::String>,
    pub args: ::protobuf::RepeatedField<::std::string::String>,
    pub env: ::protobuf::RepeatedField<::std::string::String>,
    pub output: ::std::string::String,
    pub field_type: ::std::string::String,
    pub image: ::std::string::String,
    pub namespace: ::std::string::String,
    pub secrets: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub entrypoint: ::std::string::String,
    pub volumes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateOptions {
    fn default() -> &'a CreateOptions {
        <CreateOptions as ::protobuf::Message>::default_instance()
    }
}

impl CreateOptions {
    pub fn new() -> CreateOptions {
        ::std::default::Default::default()
    }

    // repeated string command = 1;


    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // repeated string args = 2;


    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    // repeated string env = 3;


    pub fn get_env(&self) -> &[::std::string::String] {
        &self.env
    }
    pub fn clear_env(&mut self) {
        self.env.clear();
    }

    // Param is passed by value, moved
    pub fn set_env(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.env
    }

    // Take field
    pub fn take_env(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.env, ::protobuf::RepeatedField::new())
    }

    // string output = 4;


    pub fn get_output(&self) -> &str {
        &self.output
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::std::string::String) {
        self.output = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output(&mut self) -> &mut ::std::string::String {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output, ::std::string::String::new())
    }

    // string type = 5;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string image = 6;


    pub fn get_image(&self) -> &str {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image, ::std::string::String::new())
    }

    // string namespace = 7;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }

    // repeated .runtime.CreateOptions.SecretsEntry secrets = 8;


    pub fn get_secrets(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.secrets
    }
    pub fn clear_secrets(&mut self) {
        self.secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_secrets(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secrets(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.secrets
    }

    // Take field
    pub fn take_secrets(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.secrets, ::std::collections::HashMap::new())
    }

    // string entrypoint = 9;


    pub fn get_entrypoint(&self) -> &str {
        &self.entrypoint
    }
    pub fn clear_entrypoint(&mut self) {
        self.entrypoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_entrypoint(&mut self, v: ::std::string::String) {
        self.entrypoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entrypoint(&mut self) -> &mut ::std::string::String {
        &mut self.entrypoint
    }

    // Take field
    pub fn take_entrypoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entrypoint, ::std::string::String::new())
    }

    // repeated .runtime.CreateOptions.VolumesEntry volumes = 10;


    pub fn get_volumes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.volumes
    }
    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.volumes, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for CreateOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.env)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.secrets)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entrypoint)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.volumes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.env {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.output);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.field_type);
        }
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.image);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.namespace);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.secrets);
        if !self.entrypoint.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.entrypoint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.volumes);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.command {
            os.write_string(1, &v)?;
        };
        for v in &self.args {
            os.write_string(2, &v)?;
        };
        for v in &self.env {
            os.write_string(3, &v)?;
        };
        if !self.output.is_empty() {
            os.write_string(4, &self.output)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(5, &self.field_type)?;
        }
        if !self.image.is_empty() {
            os.write_string(6, &self.image)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(7, &self.namespace)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.secrets, os)?;
        if !self.entrypoint.is_empty() {
            os.write_string(9, &self.entrypoint)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.volumes, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateOptions {
        CreateOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "command",
                |m: &CreateOptions| { &m.command },
                |m: &mut CreateOptions| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "args",
                |m: &CreateOptions| { &m.args },
                |m: &mut CreateOptions| { &mut m.args },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "env",
                |m: &CreateOptions| { &m.env },
                |m: &mut CreateOptions| { &mut m.env },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output",
                |m: &CreateOptions| { &m.output },
                |m: &mut CreateOptions| { &mut m.output },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &CreateOptions| { &m.field_type },
                |m: &mut CreateOptions| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image",
                |m: &CreateOptions| { &m.image },
                |m: &mut CreateOptions| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &CreateOptions| { &m.namespace },
                |m: &mut CreateOptions| { &mut m.namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "secrets",
                |m: &CreateOptions| { &m.secrets },
                |m: &mut CreateOptions| { &mut m.secrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entrypoint",
                |m: &CreateOptions| { &m.entrypoint },
                |m: &mut CreateOptions| { &mut m.entrypoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "volumes",
                |m: &CreateOptions| { &m.volumes },
                |m: &mut CreateOptions| { &mut m.volumes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateOptions>(
                "CreateOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateOptions {
        static instance: ::protobuf::rt::LazyV2<CreateOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateOptions::new)
    }
}

impl ::protobuf::Clear for CreateOptions {
    fn clear(&mut self) {
        self.command.clear();
        self.args.clear();
        self.env.clear();
        self.output.clear();
        self.field_type.clear();
        self.image.clear();
        self.namespace.clear();
        self.secrets.clear();
        self.entrypoint.clear();
        self.volumes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateRequest {
    // message fields
    pub resource: ::protobuf::SingularPtrField<Resource>,
    pub options: ::protobuf::SingularPtrField<CreateOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateRequest {
    fn default() -> &'a CreateRequest {
        <CreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateRequest {
    pub fn new() -> CreateRequest {
        ::std::default::Default::default()
    }

    // .runtime.Resource resource = 1;


    pub fn get_resource(&self) -> &Resource {
        self.resource.as_ref().unwrap_or_else(|| <Resource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: Resource) {
        self.resource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut Resource {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> Resource {
        self.resource.take().unwrap_or_else(|| Resource::new())
    }

    // .runtime.CreateOptions options = 2;


    pub fn get_options(&self) -> &CreateOptions {
        self.options.as_ref().unwrap_or_else(|| <CreateOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: CreateOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut CreateOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> CreateOptions {
        self.options.take().unwrap_or_else(|| CreateOptions::new())
    }
}

impl ::protobuf::Message for CreateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.resource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resource.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateRequest {
        CreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                "resource",
                |m: &CreateRequest| { &m.resource },
                |m: &mut CreateRequest| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateOptions>>(
                "options",
                |m: &CreateRequest| { &m.options },
                |m: &mut CreateRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateRequest>(
                "CreateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateRequest {
        static instance: ::protobuf::rt::LazyV2<CreateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateRequest::new)
    }
}

impl ::protobuf::Clear for CreateRequest {
    fn clear(&mut self) {
        self.resource.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateResponse {
    fn default() -> &'a CreateResponse {
        <CreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateResponse {
    pub fn new() -> CreateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateResponse {
        CreateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateResponse>(
                "CreateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateResponse {
        static instance: ::protobuf::rt::LazyV2<CreateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateResponse::new)
    }
}

impl ::protobuf::Clear for CreateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadOptions {
    // message fields
    pub service: ::std::string::String,
    pub version: ::std::string::String,
    pub field_type: ::std::string::String,
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadOptions {
    fn default() -> &'a ReadOptions {
        <ReadOptions as ::protobuf::Message>::default_instance()
    }
}

impl ReadOptions {
    pub fn new() -> ReadOptions {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string type = 3;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string namespace = 4;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReadOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_type);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(3, &self.field_type)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(4, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadOptions {
        ReadOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &ReadOptions| { &m.service },
                |m: &mut ReadOptions| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &ReadOptions| { &m.version },
                |m: &mut ReadOptions| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &ReadOptions| { &m.field_type },
                |m: &mut ReadOptions| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &ReadOptions| { &m.namespace },
                |m: &mut ReadOptions| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadOptions>(
                "ReadOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadOptions {
        static instance: ::protobuf::rt::LazyV2<ReadOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadOptions::new)
    }
}

impl ::protobuf::Clear for ReadOptions {
    fn clear(&mut self) {
        self.service.clear();
        self.version.clear();
        self.field_type.clear();
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadRequest {
    // message fields
    pub options: ::protobuf::SingularPtrField<ReadOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadRequest {
    fn default() -> &'a ReadRequest {
        <ReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadRequest {
    pub fn new() -> ReadRequest {
        ::std::default::Default::default()
    }

    // .runtime.ReadOptions options = 1;


    pub fn get_options(&self) -> &ReadOptions {
        self.options.as_ref().unwrap_or_else(|| <ReadOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ReadOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut ReadOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> ReadOptions {
        self.options.take().unwrap_or_else(|| ReadOptions::new())
    }
}

impl ::protobuf::Message for ReadRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadRequest {
        ReadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadOptions>>(
                "options",
                |m: &ReadRequest| { &m.options },
                |m: &mut ReadRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadRequest>(
                "ReadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadRequest {
        static instance: ::protobuf::rt::LazyV2<ReadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadRequest::new)
    }
}

impl ::protobuf::Clear for ReadRequest {
    fn clear(&mut self) {
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadResponse {
    // message fields
    pub services: ::protobuf::RepeatedField<Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadResponse {
    fn default() -> &'a ReadResponse {
        <ReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadResponse {
    pub fn new() -> ReadResponse {
        ::std::default::Default::default()
    }

    // repeated .runtime.Service services = 1;


    pub fn get_services(&self) -> &[Service] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReadResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadResponse {
        ReadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "services",
                |m: &ReadResponse| { &m.services },
                |m: &mut ReadResponse| { &mut m.services },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadResponse>(
                "ReadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadResponse {
        static instance: ::protobuf::rt::LazyV2<ReadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadResponse::new)
    }
}

impl ::protobuf::Clear for ReadResponse {
    fn clear(&mut self) {
        self.services.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteOptions {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteOptions {
    fn default() -> &'a DeleteOptions {
        <DeleteOptions as ::protobuf::Message>::default_instance()
    }
}

impl DeleteOptions {
    pub fn new() -> DeleteOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteOptions {
        DeleteOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &DeleteOptions| { &m.namespace },
                |m: &mut DeleteOptions| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteOptions>(
                "DeleteOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteOptions {
        static instance: ::protobuf::rt::LazyV2<DeleteOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteOptions::new)
    }
}

impl ::protobuf::Clear for DeleteOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRequest {
    // message fields
    pub resource: ::protobuf::SingularPtrField<Resource>,
    pub options: ::protobuf::SingularPtrField<DeleteOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRequest {
    fn default() -> &'a DeleteRequest {
        <DeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRequest {
    pub fn new() -> DeleteRequest {
        ::std::default::Default::default()
    }

    // .runtime.Resource resource = 1;


    pub fn get_resource(&self) -> &Resource {
        self.resource.as_ref().unwrap_or_else(|| <Resource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: Resource) {
        self.resource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut Resource {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> Resource {
        self.resource.take().unwrap_or_else(|| Resource::new())
    }

    // .runtime.DeleteOptions options = 2;


    pub fn get_options(&self) -> &DeleteOptions {
        self.options.as_ref().unwrap_or_else(|| <DeleteOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: DeleteOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut DeleteOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> DeleteOptions {
        self.options.take().unwrap_or_else(|| DeleteOptions::new())
    }
}

impl ::protobuf::Message for DeleteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.resource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resource.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRequest {
        DeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                "resource",
                |m: &DeleteRequest| { &m.resource },
                |m: &mut DeleteRequest| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeleteOptions>>(
                "options",
                |m: &DeleteRequest| { &m.options },
                |m: &mut DeleteRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteRequest>(
                "DeleteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteRequest::new)
    }
}

impl ::protobuf::Clear for DeleteRequest {
    fn clear(&mut self) {
        self.resource.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteResponse {
    fn default() -> &'a DeleteResponse {
        <DeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteResponse {
    pub fn new() -> DeleteResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteResponse {
        DeleteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteResponse>(
                "DeleteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteResponse::new)
    }
}

impl ::protobuf::Clear for DeleteResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateOptions {
    // message fields
    pub namespace: ::std::string::String,
    pub entrypoint: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateOptions {
    fn default() -> &'a UpdateOptions {
        <UpdateOptions as ::protobuf::Message>::default_instance()
    }
}

impl UpdateOptions {
    pub fn new() -> UpdateOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }

    // string entrypoint = 2;


    pub fn get_entrypoint(&self) -> &str {
        &self.entrypoint
    }
    pub fn clear_entrypoint(&mut self) {
        self.entrypoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_entrypoint(&mut self, v: ::std::string::String) {
        self.entrypoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entrypoint(&mut self) -> &mut ::std::string::String {
        &mut self.entrypoint
    }

    // Take field
    pub fn take_entrypoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entrypoint, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entrypoint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        if !self.entrypoint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entrypoint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        if !self.entrypoint.is_empty() {
            os.write_string(2, &self.entrypoint)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateOptions {
        UpdateOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &UpdateOptions| { &m.namespace },
                |m: &mut UpdateOptions| { &mut m.namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entrypoint",
                |m: &UpdateOptions| { &m.entrypoint },
                |m: &mut UpdateOptions| { &mut m.entrypoint },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateOptions>(
                "UpdateOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateOptions {
        static instance: ::protobuf::rt::LazyV2<UpdateOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateOptions::new)
    }
}

impl ::protobuf::Clear for UpdateOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.entrypoint.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRequest {
    // message fields
    pub resource: ::protobuf::SingularPtrField<Resource>,
    pub options: ::protobuf::SingularPtrField<UpdateOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRequest {
    fn default() -> &'a UpdateRequest {
        <UpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRequest {
    pub fn new() -> UpdateRequest {
        ::std::default::Default::default()
    }

    // .runtime.Resource resource = 1;


    pub fn get_resource(&self) -> &Resource {
        self.resource.as_ref().unwrap_or_else(|| <Resource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: Resource) {
        self.resource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut Resource {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> Resource {
        self.resource.take().unwrap_or_else(|| Resource::new())
    }

    // .runtime.UpdateOptions options = 2;


    pub fn get_options(&self) -> &UpdateOptions {
        self.options.as_ref().unwrap_or_else(|| <UpdateOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: UpdateOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut UpdateOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> UpdateOptions {
        self.options.take().unwrap_or_else(|| UpdateOptions::new())
    }
}

impl ::protobuf::Message for UpdateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.resource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resource.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRequest {
        UpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Resource>>(
                "resource",
                |m: &UpdateRequest| { &m.resource },
                |m: &mut UpdateRequest| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateOptions>>(
                "options",
                |m: &UpdateRequest| { &m.options },
                |m: &mut UpdateRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateRequest>(
                "UpdateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateRequest::new)
    }
}

impl ::protobuf::Clear for UpdateRequest {
    fn clear(&mut self) {
        self.resource.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateResponse {
    fn default() -> &'a UpdateResponse {
        <UpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateResponse {
    pub fn new() -> UpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateResponse {
        UpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateResponse>(
                "UpdateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateResponse::new)
    }
}

impl ::protobuf::Clear for UpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOptions {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOptions {
    fn default() -> &'a ListOptions {
        <ListOptions as ::protobuf::Message>::default_instance()
    }
}

impl ListOptions {
    pub fn new() -> ListOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOptions {
        ListOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &ListOptions| { &m.namespace },
                |m: &mut ListOptions| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOptions>(
                "ListOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOptions {
        static instance: ::protobuf::rt::LazyV2<ListOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOptions::new)
    }
}

impl ::protobuf::Clear for ListOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRequest {
    // message fields
    pub options: ::protobuf::SingularPtrField<ListOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRequest {
    fn default() -> &'a ListRequest {
        <ListRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRequest {
    pub fn new() -> ListRequest {
        ::std::default::Default::default()
    }

    // .runtime.ListOptions options = 1;


    pub fn get_options(&self) -> &ListOptions {
        self.options.as_ref().unwrap_or_else(|| <ListOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ListOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut ListOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> ListOptions {
        self.options.take().unwrap_or_else(|| ListOptions::new())
    }
}

impl ::protobuf::Message for ListRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRequest {
        ListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListOptions>>(
                "options",
                |m: &ListRequest| { &m.options },
                |m: &mut ListRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListRequest>(
                "ListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListRequest {
        static instance: ::protobuf::rt::LazyV2<ListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListRequest::new)
    }
}

impl ::protobuf::Clear for ListRequest {
    fn clear(&mut self) {
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListResponse {
    // message fields
    pub services: ::protobuf::RepeatedField<Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListResponse {
    fn default() -> &'a ListResponse {
        <ListResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListResponse {
    pub fn new() -> ListResponse {
        ::std::default::Default::default()
    }

    // repeated .runtime.Service services = 1;


    pub fn get_services(&self) -> &[Service] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListResponse {
        ListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "services",
                |m: &ListResponse| { &m.services },
                |m: &mut ListResponse| { &mut m.services },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListResponse>(
                "ListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListResponse {
        static instance: ::protobuf::rt::LazyV2<ListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListResponse::new)
    }
}

impl ::protobuf::Clear for ListResponse {
    fn clear(&mut self) {
        self.services.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogsOptions {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogsOptions {
    fn default() -> &'a LogsOptions {
        <LogsOptions as ::protobuf::Message>::default_instance()
    }
}

impl LogsOptions {
    pub fn new() -> LogsOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LogsOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogsOptions {
        LogsOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &LogsOptions| { &m.namespace },
                |m: &mut LogsOptions| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogsOptions>(
                "LogsOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogsOptions {
        static instance: ::protobuf::rt::LazyV2<LogsOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogsOptions::new)
    }
}

impl ::protobuf::Clear for LogsOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogsOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogsOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogsRequest {
    // message fields
    pub service: ::std::string::String,
    pub stream: bool,
    pub count: i64,
    pub since: i64,
    pub options: ::protobuf::SingularPtrField<LogsOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogsRequest {
    fn default() -> &'a LogsRequest {
        <LogsRequest as ::protobuf::Message>::default_instance()
    }
}

impl LogsRequest {
    pub fn new() -> LogsRequest {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // bool stream = 2;


    pub fn get_stream(&self) -> bool {
        self.stream
    }
    pub fn clear_stream(&mut self) {
        self.stream = false;
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: bool) {
        self.stream = v;
    }

    // int64 count = 3;


    pub fn get_count(&self) -> i64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = v;
    }

    // int64 since = 4;


    pub fn get_since(&self) -> i64 {
        self.since
    }
    pub fn clear_since(&mut self) {
        self.since = 0;
    }

    // Param is passed by value, moved
    pub fn set_since(&mut self, v: i64) {
        self.since = v;
    }

    // .runtime.LogsOptions options = 5;


    pub fn get_options(&self) -> &LogsOptions {
        self.options.as_ref().unwrap_or_else(|| <LogsOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: LogsOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut LogsOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> LogsOptions {
        self.options.take().unwrap_or_else(|| LogsOptions::new())
    }
}

impl ::protobuf::Message for LogsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stream = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.since = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if self.stream != false {
            my_size += 2;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.since != 0 {
            my_size += ::protobuf::rt::value_size(4, self.since, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if self.stream != false {
            os.write_bool(2, self.stream)?;
        }
        if self.count != 0 {
            os.write_int64(3, self.count)?;
        }
        if self.since != 0 {
            os.write_int64(4, self.since)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogsRequest {
        LogsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &LogsRequest| { &m.service },
                |m: &mut LogsRequest| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stream",
                |m: &LogsRequest| { &m.stream },
                |m: &mut LogsRequest| { &mut m.stream },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "count",
                |m: &LogsRequest| { &m.count },
                |m: &mut LogsRequest| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "since",
                |m: &LogsRequest| { &m.since },
                |m: &mut LogsRequest| { &mut m.since },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogsOptions>>(
                "options",
                |m: &LogsRequest| { &m.options },
                |m: &mut LogsRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogsRequest>(
                "LogsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogsRequest {
        static instance: ::protobuf::rt::LazyV2<LogsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogsRequest::new)
    }
}

impl ::protobuf::Clear for LogsRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.stream = false;
        self.count = 0;
        self.since = 0;
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogRecord {
    // message fields
    pub timestamp: i64,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogRecord {
    fn default() -> &'a LogRecord {
        <LogRecord as ::protobuf::Message>::default_instance()
    }
}

impl LogRecord {
    pub fn new() -> LogRecord {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // repeated .runtime.LogRecord.MetadataEntry metadata = 2;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LogRecord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.metadata);
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.metadata, os)?;
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogRecord {
        LogRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &LogRecord| { &m.timestamp },
                |m: &mut LogRecord| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &LogRecord| { &m.metadata },
                |m: &mut LogRecord| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &LogRecord| { &m.message },
                |m: &mut LogRecord| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogRecord>(
                "LogRecord",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogRecord {
        static instance: ::protobuf::rt::LazyV2<LogRecord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogRecord::new)
    }
}

impl ::protobuf::Clear for LogRecord {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.metadata.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UploadRequest {
    // message fields
    pub service: ::protobuf::SingularPtrField<Service>,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadRequest {
    fn default() -> &'a UploadRequest {
        <UploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl UploadRequest {
    pub fn new() -> UploadRequest {
        ::std::default::Default::default()
    }

    // .runtime.Service service = 1;


    pub fn get_service(&self) -> &Service {
        self.service.as_ref().unwrap_or_else(|| <Service as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: Service) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut Service {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> Service {
        self.service.take().unwrap_or_else(|| Service::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UploadRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadRequest {
        UploadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "service",
                |m: &UploadRequest| { &m.service },
                |m: &mut UploadRequest| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &UploadRequest| { &m.data },
                |m: &mut UploadRequest| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UploadRequest>(
                "UploadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UploadRequest {
        static instance: ::protobuf::rt::LazyV2<UploadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UploadRequest::new)
    }
}

impl ::protobuf::Clear for UploadRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UploadResponse {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadResponse {
    fn default() -> &'a UploadResponse {
        <UploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl UploadResponse {
    pub fn new() -> UploadResponse {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UploadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadResponse {
        UploadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &UploadResponse| { &m.id },
                |m: &mut UploadResponse| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UploadResponse>(
                "UploadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UploadResponse {
        static instance: ::protobuf::rt::LazyV2<UploadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UploadResponse::new)
    }
}

impl ::protobuf::Clear for UploadResponse {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BuildReadResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildReadResponse {
    fn default() -> &'a BuildReadResponse {
        <BuildReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl BuildReadResponse {
    pub fn new() -> BuildReadResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BuildReadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildReadResponse {
        BuildReadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &BuildReadResponse| { &m.data },
                |m: &mut BuildReadResponse| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildReadResponse>(
                "BuildReadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildReadResponse {
        static instance: ::protobuf::rt::LazyV2<BuildReadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildReadResponse::new)
    }
}

impl ::protobuf::Clear for BuildReadResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildReadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15runtime/runtime.proto\x12\x07runtime\"\xe4\x01\n\x08Resource\x120\
    \n\tnamespace\x18\x01\x20\x01(\x0b2\x12.runtime.NamespaceR\tnamespace\
    \x12<\n\rnetworkpolicy\x18\x02\x20\x01(\x0b2\x16.runtime.NetworkPolicyR\
    \rnetworkpolicy\x12*\n\x07service\x18\x03\x20\x01(\x0b2\x10.runtime.Serv\
    iceR\x07service\x12<\n\rresourcequota\x18\x04\x20\x01(\x0b2\x16.runtime.\
    ResourceQuotaR\rresourcequota\"\x1f\n\tNamespace\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\"\xd4\x01\n\rNetworkPolicy\x12O\n\rallowedlabel\
    s\x18\x01\x20\x03(\x0b2).runtime.NetworkPolicy.AllowedlabelsEntryR\rallo\
    wedlabels\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1c\n\tnames\
    pace\x18\x03\x20\x01(\tR\tnamespace\x1a@\n\x12AllowedlabelsEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\"\x9d\x01\n\rResourceQuota\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x02\x20\x01(\tR\tnames\
    pace\x12.\n\x08requests\x18\x03\x20\x01(\x0b2\x12.runtime.ResourcesR\x08\
    requests\x12*\n\x06limits\x18\x04\x20\x01(\x0b2\x12.runtime.ResourcesR\
    \x06limits\"a\n\tResources\x12\x16\n\x06Memory\x18\x01\x20\x01(\x05R\x06\
    Memory\x12\x10\n\x03CPU\x18\x02\x20\x01(\x05R\x03CPU\x12*\n\x10Ephemeral\
    Storage\x18\x03\x20\x01(\x05R\x10EphemeralStorage\"\xe0\x01\n\x07Service\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07version\x18\
    \x02\x20\x01(\tR\x07version\x12\x16\n\x06source\x18\x03\x20\x01(\tR\x06s\
    ource\x12:\n\x08metadata\x18\x04\x20\x03(\x0b2\x1e.runtime.Service.Metad\
    ataEntryR\x08metadata\x12\x16\n\x06status\x18\x05\x20\x01(\x05R\x06statu\
    s\x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xc5\x03\n\rCrea\
    teOptions\x12\x18\n\x07command\x18\x01\x20\x03(\tR\x07command\x12\x12\n\
    \x04args\x18\x02\x20\x03(\tR\x04args\x12\x10\n\x03env\x18\x03\x20\x03(\t\
    R\x03env\x12\x16\n\x06output\x18\x04\x20\x01(\tR\x06output\x12\x12\n\x04\
    type\x18\x05\x20\x01(\tR\x04type\x12\x14\n\x05image\x18\x06\x20\x01(\tR\
    \x05image\x12\x1c\n\tnamespace\x18\x07\x20\x01(\tR\tnamespace\x12=\n\x07\
    secrets\x18\x08\x20\x03(\x0b2#.runtime.CreateOptions.SecretsEntryR\x07se\
    crets\x12\x1e\n\nentrypoint\x18\t\x20\x01(\tR\nentrypoint\x12=\n\x07volu\
    mes\x18\n\x20\x03(\x0b2#.runtime.CreateOptions.VolumesEntryR\x07volumes\
    \x1a:\n\x0cSecretsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a:\n\x0cVolumes\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"p\n\rCreateRequest\x12-\n\x08resour\
    ce\x18\x01\x20\x01(\x0b2\x11.runtime.ResourceR\x08resource\x120\n\x07opt\
    ions\x18\x02\x20\x01(\x0b2\x16.runtime.CreateOptionsR\x07options\"\x10\n\
    \x0eCreateResponse\"s\n\x0bReadOptions\x12\x18\n\x07service\x18\x01\x20\
    \x01(\tR\x07service\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\
    \x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\x12\x1c\n\tnamespace\x18\
    \x04\x20\x01(\tR\tnamespace\"=\n\x0bReadRequest\x12.\n\x07options\x18\
    \x01\x20\x01(\x0b2\x14.runtime.ReadOptionsR\x07options\"<\n\x0cReadRespo\
    nse\x12,\n\x08services\x18\x01\x20\x03(\x0b2\x10.runtime.ServiceR\x08ser\
    vices\"-\n\rDeleteOptions\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tname\
    space\"p\n\rDeleteRequest\x12-\n\x08resource\x18\x01\x20\x01(\x0b2\x11.r\
    untime.ResourceR\x08resource\x120\n\x07options\x18\x02\x20\x01(\x0b2\x16\
    .runtime.DeleteOptionsR\x07options\"\x10\n\x0eDeleteResponse\"M\n\rUpdat\
    eOptions\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespace\x12\x1e\n\n\
    entrypoint\x18\x02\x20\x01(\tR\nentrypoint\"p\n\rUpdateRequest\x12-\n\
    \x08resource\x18\x01\x20\x01(\x0b2\x11.runtime.ResourceR\x08resource\x12\
    0\n\x07options\x18\x02\x20\x01(\x0b2\x16.runtime.UpdateOptionsR\x07optio\
    ns\"\x10\n\x0eUpdateResponse\"+\n\x0bListOptions\x12\x1c\n\tnamespace\
    \x18\x01\x20\x01(\tR\tnamespace\"=\n\x0bListRequest\x12.\n\x07options\
    \x18\x01\x20\x01(\x0b2\x14.runtime.ListOptionsR\x07options\"<\n\x0cListR\
    esponse\x12,\n\x08services\x18\x01\x20\x03(\x0b2\x10.runtime.ServiceR\
    \x08services\"+\n\x0bLogsOptions\x12\x1c\n\tnamespace\x18\x01\x20\x01(\t\
    R\tnamespace\"\x9b\x01\n\x0bLogsRequest\x12\x18\n\x07service\x18\x01\x20\
    \x01(\tR\x07service\x12\x16\n\x06stream\x18\x02\x20\x01(\x08R\x06stream\
    \x12\x14\n\x05count\x18\x03\x20\x01(\x03R\x05count\x12\x14\n\x05since\
    \x18\x04\x20\x01(\x03R\x05since\x12.\n\x07options\x18\x05\x20\x01(\x0b2\
    \x14.runtime.LogsOptionsR\x07options\"\xbe\x01\n\tLogRecord\x12\x1c\n\tt\
    imestamp\x18\x01\x20\x01(\x03R\ttimestamp\x12<\n\x08metadata\x18\x02\x20\
    \x03(\x0b2\x20.runtime.LogRecord.MetadataEntryR\x08metadata\x12\x18\n\
    \x07message\x18\x03\x20\x01(\tR\x07message\x1a;\n\rMetadataEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\"O\n\rUploadRequest\x12*\n\x07service\x18\x01\x20\
    \x01(\x0b2\x10.runtime.ServiceR\x07service\x12\x12\n\x04data\x18\x02\x20\
    \x01(\x0cR\x04data\"\x20\n\x0eUploadResponse\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\"'\n\x11BuildReadResponse\x12\x12\n\x04data\x18\x01\x20\
    \x01(\x0cR\x04data2\xad\x02\n\x07Runtime\x12;\n\x06Create\x12\x16.runtim\
    e.CreateRequest\x1a\x17.runtime.CreateResponse\"\0\x125\n\x04Read\x12\
    \x14.runtime.ReadRequest\x1a\x15.runtime.ReadResponse\"\0\x12;\n\x06Dele\
    te\x12\x16.runtime.DeleteRequest\x1a\x17.runtime.DeleteResponse\"\0\x12;\
    \n\x06Update\x12\x16.runtime.UpdateRequest\x1a\x17.runtime.UpdateRespons\
    e\"\0\x124\n\x04Logs\x12\x14.runtime.LogsRequest\x1a\x12.runtime.LogReco\
    rd\"\00\x012G\n\x06Source\x12=\n\x06Upload\x12\x16.runtime.UploadRequest\
    \x1a\x17.runtime.UploadResponse\"\0(\x012A\n\x05Build\x128\n\x04Read\x12\
    \x10.runtime.Service\x1a\x1a.runtime.BuildReadResponse\"\00\x01B1Z/githu\
    b.com/micro/micro/v3/proto/runtime;runtimeJ\xd78\n\x07\x12\x05\0\0\xcf\
    \x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\
    \x0f\n\x08\n\x01\x08\x12\x03\x04\0F\n\t\n\x02\x08\x0b\x12\x03\x04\0F\n\n\
    \n\x02\x06\0\x12\x04\x06\0\x0c\x01\n\n\n\x03\x06\0\x01\x12\x03\x06\x08\
    \x0f\n\x0b\n\x04\x06\0\x02\0\x12\x03\x07\x08=\n\x0c\n\x05\x06\0\x02\0\
    \x01\x12\x03\x07\x0c\x12\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x07\x13\x20\
    \n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x07+9\n\x0b\n\x04\x06\0\x02\x01\x12\
    \x03\x08\x087\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x08\x0c\x10\n\x0c\n\
    \x05\x06\0\x02\x01\x02\x12\x03\x08\x11\x1c\n\x0c\n\x05\x06\0\x02\x01\x03\
    \x12\x03\x08'3\n\x0b\n\x04\x06\0\x02\x02\x12\x03\t\x08=\n\x0c\n\x05\x06\
    \0\x02\x02\x01\x12\x03\t\x0c\x12\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\t\
    \x13\x20\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\t+9\n\x0b\n\x04\x06\0\x02\
    \x03\x12\x03\n\x08=\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\n\x0c\x12\n\
    \x0c\n\x05\x06\0\x02\x03\x02\x12\x03\n\x13\x20\n\x0c\n\x05\x06\0\x02\x03\
    \x03\x12\x03\n+9\n\x0b\n\x04\x06\0\x02\x04\x12\x03\x0b\x08;\n\x0c\n\x05\
    \x06\0\x02\x04\x01\x12\x03\x0b\x0c\x10\n\x0c\n\x05\x06\0\x02\x04\x02\x12\
    \x03\x0b\x11\x1c\n\x0c\n\x05\x06\0\x02\x04\x06\x12\x03\x0b'-\n\x0c\n\x05\
    \x06\0\x02\x04\x03\x12\x03\x0b.7\n\n\n\x02\x04\0\x12\x04\x0e\0\x13\x01\n\
    \n\n\x03\x04\0\x01\x12\x03\x0e\x08\x10\n\x0b\n\x04\x04\0\x02\0\x12\x03\
    \x0f\x08\x20\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x0f\x08\x0e\x12\n\x0c\n\
    \x05\x04\0\x02\0\x06\x12\x03\x0f\x08\x11\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03\x0f\x12\x1b\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0f\x1e\x1f\n\x0b\n\
    \x04\x04\0\x02\x01\x12\x03\x10\x08(\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\
    \x10\x08\x0f\x20\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x10\x08\x15\n\x0c\
    \n\x05\x04\0\x02\x01\x01\x12\x03\x10\x16#\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x10&'\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x11\x08\x1c\n\r\n\x05\
    \x04\0\x02\x02\x04\x12\x04\x11\x08\x10(\n\x0c\n\x05\x04\0\x02\x02\x06\
    \x12\x03\x11\x08\x0f\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x11\x10\x17\n\
    \x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x11\x1a\x1b\n\x0b\n\x04\x04\0\x02\
    \x03\x12\x03\x12\x08(\n\r\n\x05\x04\0\x02\x03\x04\x12\x04\x12\x08\x11\
    \x1c\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03\x12\x08\x15\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x03\x12\x16#\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x12&\
    '\n\n\n\x02\x04\x01\x12\x04\x15\0\x18\x01\n\n\n\x03\x04\x01\x01\x12\x03\
    \x15\x08\x11\n$\n\x04\x04\x01\x02\0\x12\x03\x17\x08\x18\x1a\x17\x20name\
    \x20of\x20the\x20namespace\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x17\x08\
    \x15\x13\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x17\x08\x0e\n\x0c\n\x05\
    \x04\x01\x02\0\x01\x12\x03\x17\x0f\x13\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03\x17\x16\x17\n\n\n\x02\x04\x02\x12\x04\x1a\0!\x01\n\n\n\x03\x04\x02\
    \x01\x12\x03\x1a\x08\x15\n8\n\x04\x04\x02\x02\0\x12\x03\x1c\x08-\x1a+\
    \x20the\x20labels\x20allowed\x20ingress\x20by\x20this\x20policy\n\n\r\n\
    \x05\x04\x02\x02\0\x04\x12\x04\x1c\x08\x1a\x17\n\x0c\n\x05\x04\x02\x02\0\
    \x06\x12\x03\x1c\x08\x1a\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1c\x1b(\
    \n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x1c+,\n)\n\x04\x04\x02\x02\x01\
    \x12\x03\x1e\x08\x18\x1a\x1c\x20name\x20of\x20the\x20network\x20policy\n\
    \n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\x1e\x08\x1c-\n\x0c\n\x05\x04\x02\
    \x02\x01\x05\x12\x03\x1e\x08\x0e\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\
    \x1e\x0f\x13\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x1e\x16\x17\n6\n\
    \x04\x04\x02\x02\x02\x12\x03\x20\x08\x1d\x1a)\x20namespace\x20the\x20net\
    work\x20policy\x20belongs\x20to\n\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\
    \x20\x08\x1e\x18\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03\x20\x08\x0e\n\
    \x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x20\x0f\x18\n\x0c\n\x05\x04\x02\
    \x02\x02\x03\x12\x03\x20\x1b\x1c\n\n\n\x02\x04\x03\x12\x04#\0,\x01\n\n\n\
    \x03\x04\x03\x01\x12\x03#\x08\x15\n)\n\x04\x04\x03\x02\0\x12\x03%\x08\
    \x18\x1a\x1c\x20name\x20of\x20the\x20resource\x20quota\n\n\r\n\x05\x04\
    \x03\x02\0\x04\x12\x04%\x08#\x17\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03%\
    \x08\x0e\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03%\x0f\x13\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03%\x16\x17\n6\n\x04\x04\x03\x02\x01\x12\x03'\x08\
    \x1d\x1a)\x20namespace\x20the\x20resource\x20quota\x20belongs\x20to\n\n\
    \r\n\x05\x04\x03\x02\x01\x04\x12\x04'\x08%\x18\n\x0c\n\x05\x04\x03\x02\
    \x01\x05\x12\x03'\x08\x0e\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03'\x0f\
    \x18\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03'\x1b\x1c\n\x1f\n\x04\x04\
    \x03\x02\x02\x12\x03)\x08\x1f\x1a\x12\x20resource\x20requets\n\n\r\n\x05\
    \x04\x03\x02\x02\x04\x12\x04)\x08'\x1d\n\x0c\n\x05\x04\x03\x02\x02\x06\
    \x12\x03)\x08\x11\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03)\x12\x1a\n\x0c\
    \n\x05\x04\x03\x02\x02\x03\x12\x03)\x1d\x1e\n\x1e\n\x04\x04\x03\x02\x03\
    \x12\x03+\x08\x1d\x1a\x11\x20resource\x20limits\n\n\r\n\x05\x04\x03\x02\
    \x03\x04\x12\x04+\x08)\x1f\n\x0c\n\x05\x04\x03\x02\x03\x06\x12\x03+\x08\
    \x11\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03+\x12\x18\n\x0c\n\x05\x04\
    \x03\x02\x03\x03\x12\x03+\x1b\x1c\n\n\n\x02\x04\x04\x12\x04.\02\x01\n\n\
    \n\x03\x04\x04\x01\x12\x03.\x08\x11\n\x0b\n\x04\x04\x04\x02\0\x12\x03/\
    \x08\x19\n\r\n\x05\x04\x04\x02\0\x04\x12\x04/\x08.\x13\n\x0c\n\x05\x04\
    \x04\x02\0\x05\x12\x03/\x08\r\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03/\x0e\
    \x14\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03/\x17\x18\n\x0b\n\x04\x04\x04\
    \x02\x01\x12\x030\x08\x16\n\r\n\x05\x04\x04\x02\x01\x04\x12\x040\x08/\
    \x19\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x030\x08\r\n\x0c\n\x05\x04\x04\
    \x02\x01\x01\x12\x030\x0e\x11\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x030\
    \x14\x15\n\x0b\n\x04\x04\x04\x02\x02\x12\x031\x08#\n\r\n\x05\x04\x04\x02\
    \x02\x04\x12\x041\x080\x16\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x031\x08\
    \r\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x031\x0e\x1e\n\x0c\n\x05\x04\x04\
    \x02\x02\x03\x12\x031!\"\n\xa4\x02\n\x02\x06\x01\x12\x047\09\x01\x1a\x97\
    \x02\x20Source\x20service\x20is\x20used\x20by\x20the\x20CLI\x20to\x20upl\
    oad\x20source\x20to\x20the\x20service.\x20The\x20service\x20will\x20retu\
    rn\n\x20a\x20unique\x20ID\x20representing\x20the\x20location\x20of\x20th\
    at\x20source.\x20This\x20ID\x20can\x20then\x20be\x20used\x20as\x20a\x20s\
    ource\n\x20for\x20the\x20service\x20when\x20doing\x20Runtime.Create.\x20\
    The\x20server\x20will\x20handle\x20cleanup\x20of\x20uploaded\x20source.\
    \n\n\n\n\x03\x06\x01\x01\x12\x037\x08\x0e\n\x0b\n\x04\x06\x01\x02\0\x12\
    \x038\x08D\n\x0c\n\x05\x06\x01\x02\0\x01\x12\x038\x0c\x12\n\x0c\n\x05\
    \x06\x01\x02\0\x05\x12\x038\x13\x19\n\x0c\n\x05\x06\x01\x02\0\x02\x12\
    \x038\x1a'\n\x0c\n\x05\x06\x01\x02\0\x03\x12\x0382@\n\xe1\x01\n\x02\x06\
    \x02\x12\x04>\0@\x01\x1a\xd4\x01\x20Build\x20service\x20is\x20used\x20by\
    \x20containers\x20to\x20download\x20prebuilt\x20binaries.\x20The\x20clie\
    nt\x20will\x20pass\x20the\x20\n\x20service\x20(name\x20and\x20version\
    \x20are\x20required\x20attributed)\x20and\x20the\x20server\x20will\x20th\
    en\x20stream\x20the\x20latest\n\x20binary\x20to\x20the\x20client.\n\n\n\
    \n\x03\x06\x02\x01\x12\x03>\x08\r\n\x0b\n\x04\x06\x02\x02\0\x12\x03?\x08\
    ?\n\x0c\n\x05\x06\x02\x02\0\x01\x12\x03?\x0c\x10\n\x0c\n\x05\x06\x02\x02\
    \0\x02\x12\x03?\x11\x18\n\x0c\n\x05\x06\x02\x02\0\x06\x12\x03?#)\n\x0c\n\
    \x05\x06\x02\x02\0\x03\x12\x03?*;\n\n\n\x02\x04\x05\x12\x04B\0M\x01\n\n\
    \n\x03\x04\x05\x01\x12\x03B\x08\x0f\n\"\n\x04\x04\x05\x02\0\x12\x03D\x08\
    \x18\x1a\x15\x20name\x20of\x20the\x20service\n\n\r\n\x05\x04\x05\x02\0\
    \x04\x12\x04D\x08B\x11\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03D\x08\x0e\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03D\x0f\x13\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03D\x16\x17\n%\n\x04\x04\x05\x02\x01\x12\x03F\x08\x1b\x1a\x18\
    \x20version\x20of\x20the\x20service\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\
    \x04F\x08D\x18\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03F\x08\x0e\n\x0c\n\
    \x05\x04\x05\x02\x01\x01\x12\x03F\x0f\x16\n\x0c\n\x05\x04\x05\x02\x01\
    \x03\x12\x03F\x19\x1a\n$\n\x04\x04\x05\x02\x02\x12\x03H\x08\x1a\x1a\x17\
    \x20git\x20url\x20of\x20the\x20source\n\n\r\n\x05\x04\x05\x02\x02\x04\
    \x12\x04H\x08F\x1b\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03H\x08\x0e\n\
    \x0c\n\x05\x04\x05\x02\x02\x01\x12\x03H\x0f\x15\n\x0c\n\x05\x04\x05\x02\
    \x02\x03\x12\x03H\x18\x19\n\x1f\n\x04\x04\x05\x02\x03\x12\x03J\x08(\x1a\
    \x12\x20service\x20metadata\n\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04J\x08\
    H\x1a\n\x0c\n\x05\x04\x05\x02\x03\x06\x12\x03J\x08\x1a\n\x0c\n\x05\x04\
    \x05\x02\x03\x01\x12\x03J\x1b#\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03J&\
    '\n$\n\x04\x04\x05\x02\x04\x12\x03L\x08\x19\x1a\x17\x20status\x20of\x20t\
    he\x20service\n\n\r\n\x05\x04\x05\x02\x04\x04\x12\x04L\x08J(\n\x0c\n\x05\
    \x04\x05\x02\x04\x05\x12\x03L\x08\r\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\
    \x03L\x0e\x14\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03L\x17\x18\n\n\n\x02\
    \x04\x06\x12\x04O\0d\x01\n\n\n\x03\x04\x06\x01\x12\x03O\x08\x15\n!\n\x04\
    \x04\x06\x02\0\x12\x03Q\x08$\x1a\x14\x20command\x20to\x20pass\x20in\n\n\
    \x0c\n\x05\x04\x06\x02\0\x04\x12\x03Q\x08\x10\n\x0c\n\x05\x04\x06\x02\0\
    \x05\x12\x03Q\x11\x17\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03Q\x18\x1f\n\
    \x0c\n\x05\x04\x06\x02\0\x03\x12\x03Q\"#\n(\n\x04\x04\x06\x02\x01\x12\
    \x03S\x08!\x1a\x1b\x20args\x20to\x20pass\x20into\x20command\n\n\x0c\n\
    \x05\x04\x06\x02\x01\x04\x12\x03S\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\
    \x05\x12\x03S\x11\x17\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03S\x18\x1c\n\
    \x0c\n\x05\x04\x06\x02\x01\x03\x12\x03S\x1f\x20\n%\n\x04\x04\x06\x02\x02\
    \x12\x03U\x08\x20\x1a\x18\x20environment\x20to\x20pass\x20in\n\n\x0c\n\
    \x05\x04\x06\x02\x02\x04\x12\x03U\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\
    \x05\x12\x03U\x11\x17\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03U\x18\x1b\n\
    \x0c\n\x05\x04\x06\x02\x02\x03\x12\x03U\x1e\x1f\n\x20\n\x04\x04\x06\x02\
    \x03\x12\x03W\x08\x1a\x1a\x13\x20output\x20to\x20send\x20to\n\n\r\n\x05\
    \x04\x06\x02\x03\x04\x12\x04W\x08U\x20\n\x0c\n\x05\x04\x06\x02\x03\x05\
    \x12\x03W\x08\x0e\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03W\x0f\x15\n\x0c\
    \n\x05\x04\x06\x02\x03\x03\x12\x03W\x18\x19\n%\n\x04\x04\x06\x02\x04\x12\
    \x03Y\x08\x18\x1a\x18\x20create\x20type\x20of\x20service\n\n\r\n\x05\x04\
    \x06\x02\x04\x04\x12\x04Y\x08W\x1a\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\
    \x03Y\x08\x0e\n\x0c\n\x05\x04\x06\x02\x04\x01\x12\x03Y\x0f\x13\n\x0c\n\
    \x05\x04\x06\x02\x04\x03\x12\x03Y\x16\x17\n\x1b\n\x04\x04\x06\x02\x05\
    \x12\x03[\x08\x19\x1a\x0e\x20image\x20to\x20use\n\n\r\n\x05\x04\x06\x02\
    \x05\x04\x12\x04[\x08Y\x18\n\x0c\n\x05\x04\x06\x02\x05\x05\x12\x03[\x08\
    \x0e\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\x03[\x0f\x14\n\x0c\n\x05\x04\
    \x06\x02\x05\x03\x12\x03[\x17\x18\n1\n\x04\x04\x06\x02\x06\x12\x03]\x08\
    \x1d\x1a$\x20namespace\x20to\x20create\x20the\x20service\x20in\n\n\r\n\
    \x05\x04\x06\x02\x06\x04\x12\x04]\x08[\x19\n\x0c\n\x05\x04\x06\x02\x06\
    \x05\x12\x03]\x08\x0e\n\x0c\n\x05\x04\x06\x02\x06\x01\x12\x03]\x0f\x18\n\
    \x0c\n\x05\x04\x06\x02\x06\x03\x12\x03]\x1b\x1c\n-\n\x04\x04\x06\x02\x07\
    \x12\x03_\x08'\x1a\x20\x20secrets\x20to\x20use\x20for\x20the\x20service\
    \n\n\r\n\x05\x04\x06\x02\x07\x04\x12\x04_\x08]\x1d\n\x0c\n\x05\x04\x06\
    \x02\x07\x06\x12\x03_\x08\x1a\n\x0c\n\x05\x04\x06\x02\x07\x01\x12\x03_\
    \x1b\"\n\x0c\n\x05\x04\x06\x02\x07\x03\x12\x03_%&\n+\n\x04\x04\x06\x02\
    \x08\x12\x03a\x08\x1e\x1a\x1e\x20entrypoint\x20within\x20the\x20source\n\
    \n\r\n\x05\x04\x06\x02\x08\x04\x12\x04a\x08_'\n\x0c\n\x05\x04\x06\x02\
    \x08\x05\x12\x03a\x08\x0e\n\x0c\n\x05\x04\x06\x02\x08\x01\x12\x03a\x0f\
    \x19\n\x0c\n\x05\x04\x06\x02\x08\x03\x12\x03a\x1c\x1d\n\x1f\n\x04\x04\
    \x06\x02\t\x12\x03c\x08(\x1a\x12\x20volumes\x20to\x20mount\n\n\r\n\x05\
    \x04\x06\x02\t\x04\x12\x04c\x08a\x1e\n\x0c\n\x05\x04\x06\x02\t\x06\x12\
    \x03c\x08\x1a\n\x0c\n\x05\x04\x06\x02\t\x01\x12\x03c\x1b\"\n\x0c\n\x05\
    \x04\x06\x02\t\x03\x12\x03c%'\n\n\n\x02\x04\x07\x12\x04f\0i\x01\n\n\n\
    \x03\x04\x07\x01\x12\x03f\x08\x15\n\x0b\n\x04\x04\x07\x02\0\x12\x03g\x08\
    \x1e\n\r\n\x05\x04\x07\x02\0\x04\x12\x04g\x08f\x17\n\x0c\n\x05\x04\x07\
    \x02\0\x06\x12\x03g\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03g\x11\
    \x19\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03g\x1c\x1d\n\x0b\n\x04\x04\x07\
    \x02\x01\x12\x03h\x08\"\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04h\x08g\x1e\
    \n\x0c\n\x05\x04\x07\x02\x01\x06\x12\x03h\x08\x15\n\x0c\n\x05\x04\x07\
    \x02\x01\x01\x12\x03h\x16\x1d\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03h\
    \x20!\n\t\n\x02\x04\x08\x12\x03k\0\x19\n\n\n\x03\x04\x08\x01\x12\x03k\
    \x08\x16\n\n\n\x02\x04\t\x12\x04m\0v\x01\n\n\n\x03\x04\t\x01\x12\x03m\
    \x08\x13\n\x1b\n\x04\x04\t\x02\0\x12\x03o\x08\x1b\x1a\x0e\x20service\x20\
    name\n\n\r\n\x05\x04\t\x02\0\x04\x12\x04o\x08m\x15\n\x0c\n\x05\x04\t\x02\
    \0\x05\x12\x03o\x08\x0e\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03o\x0f\x16\n\
    \x0c\n\x05\x04\t\x02\0\x03\x12\x03o\x19\x1a\n%\n\x04\x04\t\x02\x01\x12\
    \x03q\x08\x1b\x1a\x18\x20version\x20of\x20the\x20service\n\n\r\n\x05\x04\
    \t\x02\x01\x04\x12\x04q\x08o\x1b\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03q\
    \x08\x0e\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03q\x0f\x16\n\x0c\n\x05\x04\
    \t\x02\x01\x03\x12\x03q\x19\x1a\n\x1e\n\x04\x04\t\x02\x02\x12\x03s\x08\
    \x18\x1a\x11\x20type\x20of\x20service\n\n\r\n\x05\x04\t\x02\x02\x04\x12\
    \x04s\x08q\x1b\n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03s\x08\x0e\n\x0c\n\
    \x05\x04\t\x02\x02\x01\x12\x03s\x0f\x13\n\x0c\n\x05\x04\t\x02\x02\x03\
    \x12\x03s\x16\x17\n'\n\x04\x04\t\x02\x03\x12\x03u\x08\x1d\x1a\x1a\x20nam\
    espace\x20of\x20the\x20service\n\n\r\n\x05\x04\t\x02\x03\x04\x12\x04u\
    \x08s\x18\n\x0c\n\x05\x04\t\x02\x03\x05\x12\x03u\x08\x0e\n\x0c\n\x05\x04\
    \t\x02\x03\x01\x12\x03u\x0f\x18\n\x0c\n\x05\x04\t\x02\x03\x03\x12\x03u\
    \x1b\x1c\n\n\n\x02\x04\n\x12\x04x\0z\x01\n\n\n\x03\x04\n\x01\x12\x03x\
    \x08\x13\n\x0b\n\x04\x04\n\x02\0\x12\x03y\x08\x20\n\r\n\x05\x04\n\x02\0\
    \x04\x12\x04y\x08x\x15\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03y\x08\x13\n\
    \x0c\n\x05\x04\n\x02\0\x01\x12\x03y\x14\x1b\n\x0c\n\x05\x04\n\x02\0\x03\
    \x12\x03y\x1e\x1f\n\n\n\x02\x04\x0b\x12\x04|\0~\x01\n\n\n\x03\x04\x0b\
    \x01\x12\x03|\x08\x14\n\x0b\n\x04\x04\x0b\x02\0\x12\x03}\x08&\n\x0c\n\
    \x05\x04\x0b\x02\0\x04\x12\x03}\x08\x10\n\x0c\n\x05\x04\x0b\x02\0\x06\
    \x12\x03}\x11\x18\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03}\x19!\n\x0c\n\
    \x05\x04\x0b\x02\0\x03\x12\x03}$%\n\x0c\n\x02\x04\x0c\x12\x06\x80\x01\0\
    \x83\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x80\x01\x08\x15\n(\n\x04\
    \x04\x0c\x02\0\x12\x04\x82\x01\x08\x1d\x1a\x1a\x20namespace\x20of\x20the\
    \x20service\n\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\x82\x01\x08\x80\x01\
    \x17\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x82\x01\x08\x0e\n\r\n\x05\x04\
    \x0c\x02\0\x01\x12\x04\x82\x01\x0f\x18\n\r\n\x05\x04\x0c\x02\0\x03\x12\
    \x04\x82\x01\x1b\x1c\n\x0c\n\x02\x04\r\x12\x06\x85\x01\0\x88\x01\x01\n\
    \x0b\n\x03\x04\r\x01\x12\x04\x85\x01\x08\x15\n\x0c\n\x04\x04\r\x02\0\x12\
    \x04\x86\x01\x08\x1e\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\x86\x01\x08\x85\
    \x01\x17\n\r\n\x05\x04\r\x02\0\x06\x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\x86\x01\x11\x19\n\r\n\x05\x04\r\x02\0\x03\x12\x04\
    \x86\x01\x1c\x1d\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x87\x01\x08\"\n\x0f\n\
    \x05\x04\r\x02\x01\x04\x12\x06\x87\x01\x08\x86\x01\x1e\n\r\n\x05\x04\r\
    \x02\x01\x06\x12\x04\x87\x01\x08\x15\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\
    \x87\x01\x16\x1d\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x87\x01\x20!\n\n\n\
    \x02\x04\x0e\x12\x04\x8a\x01\0\x19\n\x0b\n\x03\x04\x0e\x01\x12\x04\x8a\
    \x01\x08\x16\n\x0c\n\x02\x04\x0f\x12\x06\x8c\x01\0\x91\x01\x01\n\x0b\n\
    \x03\x04\x0f\x01\x12\x04\x8c\x01\x08\x15\n(\n\x04\x04\x0f\x02\0\x12\x04\
    \x8e\x01\x08\x1d\x1a\x1a\x20namespace\x20of\x20the\x20service\n\n\x0f\n\
    \x05\x04\x0f\x02\0\x04\x12\x06\x8e\x01\x08\x8c\x01\x17\n\r\n\x05\x04\x0f\
    \x02\0\x05\x12\x04\x8e\x01\x08\x0e\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\
    \x8e\x01\x0f\x18\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\x8e\x01\x1b\x1c\n,\
    \n\x04\x04\x0f\x02\x01\x12\x04\x90\x01\x08\x1e\x1a\x1e\x20entrypoint\x20\
    within\x20the\x20source\n\n\x0f\n\x05\x04\x0f\x02\x01\x04\x12\x06\x90\
    \x01\x08\x8e\x01\x1d\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\x90\x01\x08\
    \x0e\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x90\x01\x0f\x19\n\r\n\x05\x04\
    \x0f\x02\x01\x03\x12\x04\x90\x01\x1c\x1d\n\x0c\n\x02\x04\x10\x12\x06\x93\
    \x01\0\x96\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x93\x01\x08\x15\n\x0c\
    \n\x04\x04\x10\x02\0\x12\x04\x94\x01\x08\x1e\n\x0f\n\x05\x04\x10\x02\0\
    \x04\x12\x06\x94\x01\x08\x93\x01\x17\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\
    \x94\x01\x08\x10\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x94\x01\x11\x19\n\r\
    \n\x05\x04\x10\x02\0\x03\x12\x04\x94\x01\x1c\x1d\n\x0c\n\x04\x04\x10\x02\
    \x01\x12\x04\x95\x01\x08\"\n\x0f\n\x05\x04\x10\x02\x01\x04\x12\x06\x95\
    \x01\x08\x94\x01\x1e\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\x95\x01\x08\
    \x15\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\x95\x01\x16\x1d\n\r\n\x05\x04\
    \x10\x02\x01\x03\x12\x04\x95\x01\x20!\n\n\n\x02\x04\x11\x12\x04\x98\x01\
    \0\x19\n\x0b\n\x03\x04\x11\x01\x12\x04\x98\x01\x08\x16\n\x0c\n\x02\x04\
    \x12\x12\x06\x9a\x01\0\x9d\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x9a\
    \x01\x08\x13\n(\n\x04\x04\x12\x02\0\x12\x04\x9c\x01\x08\x1d\x1a\x1a\x20n\
    amespace\x20of\x20the\x20service\n\n\x0f\n\x05\x04\x12\x02\0\x04\x12\x06\
    \x9c\x01\x08\x9a\x01\x15\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x9c\x01\x08\
    \x0e\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\x9c\x01\x0f\x18\n\r\n\x05\x04\
    \x12\x02\0\x03\x12\x04\x9c\x01\x1b\x1c\n\x0c\n\x02\x04\x13\x12\x06\x9f\
    \x01\0\xa1\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\x9f\x01\x08\x13\n\x0c\
    \n\x04\x04\x13\x02\0\x12\x04\xa0\x01\x08\x20\n\x0f\n\x05\x04\x13\x02\0\
    \x04\x12\x06\xa0\x01\x08\x9f\x01\x15\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\
    \xa0\x01\x08\x13\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xa0\x01\x14\x1b\n\r\
    \n\x05\x04\x13\x02\0\x03\x12\x04\xa0\x01\x1e\x1f\n\x0c\n\x02\x04\x14\x12\
    \x06\xa3\x01\0\xa5\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xa3\x01\x08\
    \x14\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xa4\x01\x08&\n\r\n\x05\x04\x14\
    \x02\0\x04\x12\x04\xa4\x01\x08\x10\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\
    \xa4\x01\x11\x18\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xa4\x01\x19!\n\r\n\
    \x05\x04\x14\x02\0\x03\x12\x04\xa4\x01$%\n\x0c\n\x02\x04\x15\x12\x06\xa7\
    \x01\0\xaa\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xa7\x01\x08\x13\n(\n\
    \x04\x04\x15\x02\0\x12\x04\xa9\x01\x08\x1d\x1a\x1a\x20namespace\x20of\
    \x20the\x20service\n\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\xa9\x01\x08\
    \xa7\x01\x15\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xa9\x01\x08\x0e\n\r\n\
    \x05\x04\x15\x02\0\x01\x12\x04\xa9\x01\x0f\x18\n\r\n\x05\x04\x15\x02\0\
    \x03\x12\x04\xa9\x01\x1b\x1c\n\x0c\n\x02\x04\x16\x12\x06\xac\x01\0\xb9\
    \x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xac\x01\x08\x13\n+\n\x04\x04\
    \x16\x02\0\x12\x04\xae\x01\x08\x1b\x1a\x1d\x20service\x20to\x20request\
    \x20logs\x20for\n\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\xae\x01\x08\xac\
    \x01\x14\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xae\x01\x08\x0e\n\r\n\x05\
    \x04\x16\x02\0\x01\x12\x04\xae\x01\x0f\x16\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xae\x01\x19\x1a\n+\n\x04\x04\x16\x02\x01\x12\x04\xb0\x01\x08\
    \x18\x1a\x1d\x20stream\x20records\x20continuously\n\n\x0f\n\x05\x04\x16\
    \x02\x01\x04\x12\x06\xb0\x01\x08\xae\x01\x1b\n\r\n\x05\x04\x16\x02\x01\
    \x05\x12\x04\xb0\x01\x08\x0c\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xb0\
    \x01\r\x13\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xb0\x01\x16\x17\n+\n\
    \x04\x04\x16\x02\x02\x12\x04\xb2\x01\x08\x18\x1a\x1d\x20count\x20of\x20r\
    ecords\x20to\x20request\n\n\x0f\n\x05\x04\x16\x02\x02\x04\x12\x06\xb2\
    \x01\x08\xb0\x01\x18\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xb2\x01\x08\r\
    \n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xb2\x01\x0e\x13\n\r\n\x05\x04\x16\
    \x02\x02\x03\x12\x04\xb2\x01\x16\x17\nZ\n\x04\x04\x16\x02\x03\x12\x04\
    \xb6\x01\x08\x18\x1aL\x20relative\x20time\x20in\x20seconds\n\x20before\
    \x20the\x20current\x20time\n\x20from\x20which\x20to\x20show\x20logs\n\n\
    \x0f\n\x05\x04\x16\x02\x03\x04\x12\x06\xb6\x01\x08\xb2\x01\x18\n\r\n\x05\
    \x04\x16\x02\x03\x05\x12\x04\xb6\x01\x08\r\n\r\n\x05\x04\x16\x02\x03\x01\
    \x12\x04\xb6\x01\x0e\x13\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\xb6\x01\
    \x16\x17\n\x1e\n\x04\x04\x16\x02\x04\x12\x04\xb8\x01\x08\x20\x1a\x10\x20\
    options\x20to\x20use\n\n\x0f\n\x05\x04\x16\x02\x04\x04\x12\x06\xb8\x01\
    \x08\xb6\x01\x18\n\r\n\x05\x04\x16\x02\x04\x06\x12\x04\xb8\x01\x08\x13\n\
    \r\n\x05\x04\x16\x02\x04\x01\x12\x04\xb8\x01\x14\x1b\n\r\n\x05\x04\x16\
    \x02\x04\x03\x12\x04\xb8\x01\x1e\x1f\n\x0c\n\x02\x04\x17\x12\x06\xbb\x01\
    \0\xc2\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xbb\x01\x08\x11\n'\n\x04\
    \x04\x17\x02\0\x12\x04\xbd\x01\x08\x1c\x1a\x19\x20timestamp\x20of\x20log\
    \x20record\n\n\x0f\n\x05\x04\x17\x02\0\x04\x12\x06\xbd\x01\x08\xbb\x01\
    \x13\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xbd\x01\x08\r\n\r\n\x05\x04\x17\
    \x02\0\x01\x12\x04\xbd\x01\x0e\x17\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\
    \xbd\x01\x1a\x1b\n\x1f\n\x04\x04\x17\x02\x01\x12\x04\xbf\x01\x08(\x1a\
    \x11\x20record\x20metadata\n\n\x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\xbf\
    \x01\x08\xbd\x01\x1c\n\r\n\x05\x04\x17\x02\x01\x06\x12\x04\xbf\x01\x08\
    \x1a\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xbf\x01\x1b#\n\r\n\x05\x04\
    \x17\x02\x01\x03\x12\x04\xbf\x01&'\n\x17\n\x04\x04\x17\x02\x02\x12\x04\
    \xc1\x01\x08\x1b\x1a\t\x20message\n\n\x0f\n\x05\x04\x17\x02\x02\x04\x12\
    \x06\xc1\x01\x08\xbf\x01(\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xc1\x01\
    \x08\x0e\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xc1\x01\x0f\x16\n\r\n\x05\
    \x04\x17\x02\x02\x03\x12\x04\xc1\x01\x19\x1a\n\x0c\n\x02\x04\x18\x12\x06\
    \xc4\x01\0\xc7\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xc4\x01\x08\x15\n\
    \x0c\n\x04\x04\x18\x02\0\x12\x04\xc5\x01\x08\x1c\n\x0f\n\x05\x04\x18\x02\
    \0\x04\x12\x06\xc5\x01\x08\xc4\x01\x17\n\r\n\x05\x04\x18\x02\0\x06\x12\
    \x04\xc5\x01\x08\x0f\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xc5\x01\x10\x17\
    \n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xc5\x01\x1a\x1b\n\x0c\n\x04\x04\x18\
    \x02\x01\x12\x04\xc6\x01\x08\x17\n\x0f\n\x05\x04\x18\x02\x01\x04\x12\x06\
    \xc6\x01\x08\xc5\x01\x1c\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xc6\x01\
    \x08\r\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xc6\x01\x0e\x12\n\r\n\x05\
    \x04\x18\x02\x01\x03\x12\x04\xc6\x01\x15\x16\n\x0c\n\x02\x04\x19\x12\x06\
    \xc9\x01\0\xcb\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xc9\x01\x08\x16\n\
    \x0c\n\x04\x04\x19\x02\0\x12\x04\xca\x01\x08\x16\n\x0f\n\x05\x04\x19\x02\
    \0\x04\x12\x06\xca\x01\x08\xc9\x01\x18\n\r\n\x05\x04\x19\x02\0\x05\x12\
    \x04\xca\x01\x08\x0e\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xca\x01\x0f\x11\
    \n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xca\x01\x14\x15\n\x0c\n\x02\x04\x1a\
    \x12\x06\xcd\x01\0\xcf\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xcd\x01\
    \x08\x19\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xce\x01\x08\x17\n\x0f\n\x05\
    \x04\x1a\x02\0\x04\x12\x06\xce\x01\x08\xcd\x01\x1b\n\r\n\x05\x04\x1a\x02\
    \0\x05\x12\x04\xce\x01\x08\r\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xce\x01\
    \x0e\x12\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xce\x01\x15\x16b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
